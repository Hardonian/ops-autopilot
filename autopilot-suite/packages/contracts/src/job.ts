import { z } from 'zod';
import { ISODateTimeSchema, IdentifierSchema, JSONValueSchema, PrioritySchema, SemVerSchema } from './core.js';
import { TenantContextSchema } from './tenant.js';
import { EvidenceSchema } from './evidence.js';

/**
 * JobRequest - JobForge job request payload schema
 * 
 * JobRequests are generated by Autopilot modules to request execution
 * of an action. They are "runnerless" - they only generate the request
 * payload and do not execute anything.
 * 
 * IMPORTANT: These payloads require policy tokens and JobForge-side
 * gating before execution. Autopilot modules never execute actions directly.
 */

/** Job type enumeration (extensible) */
export const JobTypeSchema = z.enum([
  // Growth jobs
  'autopilot.growth.seo_scan',
  'autopilot.growth.experiment_propose',
  'autopilot.growth.content_draft',
  'autopilot.growth.funnel_analyze',
  
  // Ops jobs
  'autopilot.ops.health_check',
  'autopilot.ops.incident_correlate',
  'autopilot.ops.metric_aggregate',
  'autopilot.ops.cost_analyze',
  'autopilot.ops.alert_correlate',
  'autopilot.ops.runbook_generate',
  'autopilot.ops.reliability_report',
  
  // Support jobs
  'autopilot.support.ticket_classify',
  'autopilot.support.response_draft',
  'autopilot.support.kb_generate',
  'autopilot.support.sentiment_analyze',
  
  // FinOps jobs
  'autopilot.finops.usage_analyze',
  'autopilot.finops.budget_check',
  'autopilot.finops.cost_optimize',
  'autopilot.finops.anomaly_detect',
]);

export type JobType = z.infer<typeof JobTypeSchema>;

/** Policy requirements for job execution */
export const PolicyRequirementsSchema = z.object({
  /** Whether policy token is required */
  requires_policy_token: z.boolean().default(true),
  
  /** Required policy scopes */
  required_scopes: z.array(z.string()).default([]),
  
  /** Approval requirements */
  requires_approval: z.boolean().default(false),
  approver_roles: z.array(z.string()).optional(),
  
  /** Risk level assessment */
  risk_level: z.enum(['low', 'medium', 'high', 'critical']).default('low'),
  
  /** Compliance tags */
  compliance_tags: z.array(z.string()).default([]),
});

export type PolicyRequirements = z.infer<typeof PolicyRequirementsSchema>;

/** Cost estimate for job execution */
export const CostEstimateSchema = z.object({
  /** Estimated credits required */
  credits: z.number().nonnegative(),
  
  /** Confidence in estimate */
  confidence: z.enum(['low', 'medium', 'high']).default('medium'),
  
  /** Breakdown by component */
  breakdown: z.record(z.string(), z.number().nonnegative()).optional(),
});

export type CostEstimate = z.infer<typeof CostEstimateSchema>;

/** Job request - payload for JobForge */
export const JobRequestSchema = z.object({
  /** Request version */
  version: SemVerSchema.default('1.0.0'),
  
  /** Job type */
  job_type: JobTypeSchema,
  
  /** Tenant context */
  tenant_context: TenantContextSchema,
  
  /** Priority level */
  priority: PrioritySchema.default('normal'),
  
  /** When request was created */
  requested_at: ISODateTimeSchema,
  
  /** When request expires (optional) */
  expires_at: ISODateTimeSchema.optional(),
  
  /** Job-specific payload */
  payload: z.record(z.string(), JSONValueSchema),
  
  /** Evidence links justifying this request */
  evidence_links: z.array(z.object({
    type: z.string(),
    id: z.string(),
    description: z.string(),
    url: z.string().optional(),
  })).default([]),
  
  /** Policy requirements */
  policy: PolicyRequirementsSchema.default({}),
  
  /** Cost estimate */
  cost_estimate: CostEstimateSchema.optional(),
  
  /** Execution constraints */
  constraints: z.object({
    max_duration_ms: z.number().int().positive().optional(),
    allowed_runners: z.array(z.string()).optional(),
    requires_isolation: z.boolean().default(false),
  }).optional(),
  
  /** Callback configuration (optional) */
  callback: z.object({
    url: z.string().url(),
    headers: z.record(z.string()).optional(),
    retry_policy: z.enum(['none', 'linear', 'exponential']).default('exponential'),
  }).optional(),
  
  /** Metadata */
  metadata: z.record(z.string(), JSONValueSchema).default({}),
});

export type JobRequest = z.infer<typeof JobRequestSchema>;

/**
 * Job request batch - multiple requests grouped together
 */
export const JobRequestBatchSchema = z.object({
  /** Batch identifier */
  batch_id: z.string().uuid(),
  
  /** Tenant context (shared across batch) */
  tenant_context: TenantContextSchema,
  
  /** Requests in batch */
  requests: z.array(JobRequestSchema),
  
  /** Total cost estimate */
  total_cost: CostEstimateSchema.optional(),
  
  /** Batch metadata */
  metadata: z.record(z.string(), JSONValueSchema).default({}),
  
  /** Created timestamp */
  created_at: ISODateTimeSchema,
});

export type JobRequestBatch = z.infer<typeof JobRequestBatchSchema>;

/**
 * Create a job request
 * @param job_type - Type of job to request
 * @param tenant_context - Tenant/project context
 * @param payload - Job-specific data
 * @returns Validated job request
 */
export function createJobRequest(
  job_type: JobType,
  tenant_context: { tenant_id: string; project_id: string },
  payload: Record<string, unknown>,
  options?: {
    priority?: 'low' | 'normal' | 'high' | 'critical';
    evidence_links?: z.infer<typeof JobRequestSchema.shape.evidence_links>;
    cost_estimate?: CostEstimate;
    expires_at?: string;
  }
): JobRequest {
  return JobRequestSchema.parse({
    version: '1.0.0',
    job_type,
    tenant_context: TenantContextSchema.parse(tenant_context),
    priority: options?.priority ?? 'normal',
    requested_at: new Date().toISOString(),
    payload,
    evidence_links: options?.evidence_links ?? [],
    policy: {
      requires_policy_token: true,
      risk_level: 'low',
    },
    cost_estimate: options?.cost_estimate,
    expires_at: options?.expires_at,
    metadata: {},
  });
}

/**
 * Batch multiple job requests
 * @param requests - Array of job requests
 * @returns Batched request object
 */
export function batchJobRequests(
  requests: JobRequest[]
): JobRequestBatch {
  if (requests.length === 0) {
    throw new Error('Cannot create empty batch');
  }
  
  // Validate all requests share same tenant
  const tenant = requests[0].tenant_context;
  for (const req of requests) {
    if (
      req.tenant_context.tenant_id !== tenant.tenant_id ||
      req.tenant_context.project_id !== tenant.project_id
    ) {
      throw new Error('All requests in batch must share same tenant_context');
    }
  }
  
  const totalCredits = requests.reduce(
    (sum, r) => sum + (r.cost_estimate?.credits ?? 0),
    0
  );
  
  return JobRequestBatchSchema.parse({
    batch_id: crypto.randomUUID(),
    tenant_context: tenant,
    requests,
    total_cost: {
      credits: totalCredits,
      confidence: 'medium',
    },
    created_at: new Date().toISOString(),
  });
}

/**
 * Serialize job request to JSON string
 * @param request - Job request
 * @returns JSON string (pretty-printed)
 */
export function serializeJobRequest(request: JobRequest): string {
  return JSON.stringify(request, null, 2);
}

/**
 * Serialize job batch to JSON string
 * @param batch - Job request batch
 * @returns JSON string (pretty-printed)
 */
export function serializeJobBatch(batch: JobRequestBatch): string {
  return JSON.stringify(batch, null, 2);
}
