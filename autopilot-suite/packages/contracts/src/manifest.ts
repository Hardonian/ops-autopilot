import { z } from 'zod';
import { ISODateTimeSchema, IdentifierSchema, JSONValueSchema, SemVerSchema } from './core.js';
import { TenantContextSchema } from './tenant.js';
import { EvidenceSchema } from './evidence.js';

/**
 * RunManifest - JobForge-compatible run manifest schema
 * 
 * Run manifests describe the execution context and outputs of a job.
 * They are generated by JobForge after job execution and returned
 * to the calling system.
 */

/** Run status enumeration */
export const RunStatusSchema = z.enum([
  'pending',
  'queued',
  'running',
  'paused',
  'completed',
  'failed',
  'cancelled',
  'timeout',
]);

export type RunStatus = z.infer<typeof RunStatusSchema>;

/** Run outcome enumeration */
export const RunOutcomeSchema = z.enum([
  'success',
  'partial_success',
  'failure',
  'cancelled',
  'timeout',
]);

export type RunOutcome = z.infer<typeof RunOutcomeSchema>;

/** Artifact produced by a run */
export const ArtifactSchema = z.object({
  artifact_id: z.string().uuid(),
  name: z.string(),
  type: z.string(),
  mime_type: z.string().optional(),
  size_bytes: z.number().int().nonnegative().optional(),
  checksum: z.string().optional(),
  metadata: z.record(z.string(), JSONValueSchema).optional(),
});

export type Artifact = z.infer<typeof ArtifactSchema>;

/** Run manifest - describes job execution */
export const RunManifestSchema = z.object({
  /** Manifest version */
  version: SemVerSchema,
  
  /** Unique run identifier */
  run_id: z.string().uuid(),
  
  /** Job type that was executed */
  job_type: z.string(),
  
  /** Tenant context */
  tenant_context: TenantContextSchema,
  
  /** Current status */
  status: RunStatusSchema,
  
  /** Final outcome (set when completed) */
  outcome: RunOutcomeSchema.optional(),
  
  /** Timestamps */
  created_at: ISODateTimeSchema,
  started_at: ISODateTimeSchema.optional(),
  completed_at: ISODateTimeSchema.optional(),
  
  /** Execution duration in milliseconds */
  duration_ms: z.number().int().nonnegative().optional(),
  
  /** Evidence collected during run */
  evidence: z.array(EvidenceSchema),
  
  /** Artifacts produced by run */
  artifacts: z.array(ArtifactSchema).default([]),
  
  /** Outputs from the run */
  outputs: z.record(z.string(), JSONValueSchema).default({}),
  
  /** Error information (if failed) */
  error: z.object({
    code: z.string(),
    message: z.string(),
    details: JSONValueSchema.optional(),
    stack_trace: z.string().optional(),
  }).optional(),
  
  /** Resource usage */
  resources: z.object({
    cpu_ms: z.number().nonnegative().optional(),
    memory_mb: z.number().nonnegative().optional(),
    cost_credits: z.number().nonnegative().optional(),
  }).optional(),
  
  /** Metadata */
  metadata: z.object({
    runner_version: z.string().optional(),
    policy_version: z.string().optional(),
    correlation_id: z.string().optional(),
  }).optional(),
});

export type RunManifest = z.infer<typeof RunManifestSchema>;

/**
 * Create a new run manifest
 * @param job_type - Type of job
 * @param tenant_context - Tenant/project context
 * @returns Initial run manifest (pending status)
 */
export function createRunManifest(
  job_type: string,
  tenant_context: { tenant_id: string; project_id: string }
): RunManifest {
  const now = new Date().toISOString();
  
  return RunManifestSchema.parse({
    version: '1.0.0',
    run_id: crypto.randomUUID(),
    job_type,
    tenant_context: TenantContextSchema.parse(tenant_context),
    status: 'pending',
    created_at: now,
    evidence: [],
    artifacts: [],
    outputs: {},
  });
}

/**
 * Update run status
 * @param manifest - Current manifest
 * @param status - New status
 * @returns Updated manifest
 */
export function updateRunStatus(
  manifest: RunManifest,
  status: RunStatus
): RunManifest {
  const updates: Partial<RunManifest> = { status };
  
  if (status === 'running' && !manifest.started_at) {
    updates.started_at = new Date().toISOString();
  }
  
  if (['completed', 'failed', 'cancelled', 'timeout'].includes(status)) {
    updates.completed_at = new Date().toISOString();
    if (manifest.started_at) {
      updates.duration_ms = Date.now() - new Date(manifest.started_at).getTime();
    }
  }
  
  return { ...manifest, ...updates };
}